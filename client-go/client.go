// Package client provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/deepmap/oapi-codegen version v1.12.4 DO NOT EDIT.
package client

import (
	"context"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"net/url"
	"strings"
	"time"

	"github.com/deepmap/oapi-codegen/pkg/runtime"
)

const (
	Basic_authScopes    = "basic_auth.Scopes"
	Pestore_authScopes  = "pestore_auth.Scopes"
	Petstore_authScopes = "petstore_auth.Scopes"
)

// Defines values for ArrangementAttributesMeter.
const (
	N128 ArrangementAttributesMeter = "12/8"
	N22  ArrangementAttributesMeter = "2/2"
	N24  ArrangementAttributesMeter = "2/4"
	N34  ArrangementAttributesMeter = "3/4"
	N38  ArrangementAttributesMeter = "3/8"
	N44  ArrangementAttributesMeter = "4/4"
	N54  ArrangementAttributesMeter = "5/4"
	N64  ArrangementAttributesMeter = "6/4"
	N68  ArrangementAttributesMeter = "6/8"
	N78  ArrangementAttributesMeter = "7/8"
	N98  ArrangementAttributesMeter = "9/8"
)

// Defines values for ArrangementAttributesPrintMargin.
const (
	N00in  ArrangementAttributesPrintMargin = "0.0in"
	N025in ArrangementAttributesPrintMargin = "0.25in"
	N05in  ArrangementAttributesPrintMargin = "0.5in"
	N075in ArrangementAttributesPrintMargin = "0.75in"
	N10in  ArrangementAttributesPrintMargin = "1.0in"
)

// Defines values for ArrangementAttributesPrintOrientation.
const (
	Landscape ArrangementAttributesPrintOrientation = "Landscape"
	Portrait  ArrangementAttributesPrintOrientation = "Portrait"
)

// Defines values for ArrangementAttributesPrintPageSize.
const (
	A4             ArrangementAttributesPrintPageSize = "A4"
	Fullscreen4x3  ArrangementAttributesPrintPageSize = "Fullscreen (4x3)"
	Legal          ArrangementAttributesPrintPageSize = "Legal"
	Letter         ArrangementAttributesPrintPageSize = "Letter"
	N11x17         ArrangementAttributesPrintPageSize = "11x17"
	Widescreen16x9 ArrangementAttributesPrintPageSize = "Widescreen (16x9)"
)

// Defines values for ListOrderParam.
const (
	ListOrderParamCreatedAt       ListOrderParam = "created_at"
	ListOrderParamLastScheduledAt ListOrderParam = "last_scheduled_at"
	ListOrderParamNone            ListOrderParam = "none"
	ListOrderParamTitle           ListOrderParam = "title"
	ListOrderParamUpdatedAt       ListOrderParam = "updated_at"
)

// Defines values for GetSongsParamsOrder.
const (
	GetSongsParamsOrderCreatedAt       GetSongsParamsOrder = "created_at"
	GetSongsParamsOrderLastScheduledAt GetSongsParamsOrder = "last_scheduled_at"
	GetSongsParamsOrderNone            GetSongsParamsOrder = "none"
	GetSongsParamsOrderTitle           GetSongsParamsOrder = "title"
	GetSongsParamsOrderUpdatedAt       GetSongsParamsOrder = "updated_at"
)

// Defines values for GetArrangementsParamsInclude.
const (
	Keys     GetArrangementsParamsInclude = "keys"
	Sections GetArrangementsParamsInclude = "sections"
)

// Arrangement defines model for Arrangement.
type Arrangement struct {
	Attributes struct {
		ArchivedAt           *time.Time                             `json:"archived_at,omitempty"`
		Bpm                  *float32                               `json:"bpm,omitempty"`
		ChordChart           *string                                `json:"chord_chart,omitempty"`
		ChordChartChordColor *int                                   `json:"chord_chart_chord_color,omitempty"`
		ChordChartColumns    *int                                   `json:"chord_chart_columns,omitempty"`
		ChordChartFont       *string                                `json:"chord_chart_font,omitempty"`
		ChordChartFontSize   *int                                   `json:"chord_chart_font_size,omitempty"`
		ChordChartKey        *string                                `json:"chord_chart_key,omitempty"`
		CreatedAt            *time.Time                             `json:"created_at,omitempty"`
		HasChordChart        *bool                                  `json:"has_chord_chart,omitempty"`
		HasChords            *bool                                  `json:"has_chords,omitempty"`
		Length               *int                                   `json:"length,omitempty"`
		Lyrics               *string                                `json:"lyrics,omitempty"`
		LyricsEnabled        *bool                                  `json:"lyrics_enabled,omitempty"`
		Meter                *ArrangementAttributesMeter            `json:"meter,omitempty"`
		Name                 string                                 `json:"name"`
		Notes                *string                                `json:"notes,omitempty"`
		NumberChartEnabled   *bool                                  `json:"number_chart_enabled,omitempty"`
		NumeralChartEnabled  *bool                                  `json:"numeral_chart_enabled,omitempty"`
		PrintMargin          *ArrangementAttributesPrintMargin      `json:"print_margin,omitempty"`
		PrintOrientation     *ArrangementAttributesPrintOrientation `json:"print_orientation,omitempty"`
		PrintPageSize        *ArrangementAttributesPrintPageSize    `json:"print_page_size,omitempty"`
		Sequence             *[]string                              `json:"sequence,omitempty"`
		SequenceFull         *[]struct {
			Id     *int    `json:"id,omitempty"`
			Label  *string `json:"label,omitempty"`
			Number *int    `json:"number,omitempty"`
		} `json:"sequence_full,omitempty"`
		SequenceShort *[]string  `json:"sequence_short,omitempty"`
		UpdatedAt     *time.Time `json:"updated_at,omitempty"`
	} `json:"attributes"`
	Id            string         `json:"id"`
	Links         *Links         `json:"links,omitempty"`
	Relationships *Relationships `json:"relationships,omitempty"`
	Type          string         `json:"type"`
}

// ArrangementAttributesMeter defines model for Arrangement.Attributes.Meter.
type ArrangementAttributesMeter string

// ArrangementAttributesPrintMargin defines model for Arrangement.Attributes.PrintMargin.
type ArrangementAttributesPrintMargin string

// ArrangementAttributesPrintOrientation defines model for Arrangement.Attributes.PrintOrientation.
type ArrangementAttributesPrintOrientation string

// ArrangementAttributesPrintPageSize defines model for Arrangement.Attributes.PrintPageSize.
type ArrangementAttributesPrintPageSize string

// ArrangementListResponse defines model for ArrangementListResponse.
type ArrangementListResponse struct {
	Data     []Arrangement            `json:"data"`
	Included []map[string]interface{} `json:"included"`
	Links    Links                    `json:"links"`
	Meta     ListMeta                 `json:"meta"`
}

// ArrangementResponse defines model for ArrangementResponse.
type ArrangementResponse struct {
	Data     Arrangement              `json:"data"`
	Included []map[string]interface{} `json:"included"`
	Meta     ObjectMeta               `json:"meta"`
}

// ArrangementSections defines model for ArrangementSections.
type ArrangementSections struct {
	Attributes struct {
		Sections []struct {
			BreaksAt *string `json:"breaks_at,omitempty"`
			Label    string  `json:"label"`
			Lyrics   string  `json:"lyrics"`
		} `json:"sections"`
	} `json:"attributes"`
	Id            string         `json:"id"`
	Links         *Links         `json:"links,omitempty"`
	Relationships *Relationships `json:"relationships,omitempty"`
	Type          string         `json:"type"`
}

// ArrangementSectionsResponse defines model for ArrangementSectionsResponse.
type ArrangementSectionsResponse struct {
	Data     ArrangementSections      `json:"data"`
	Included []map[string]interface{} `json:"included"`
	Meta     ObjectMeta               `json:"meta"`
}

// BaseDataObject defines model for BaseDataObject.
type BaseDataObject struct {
	Id            string         `json:"id"`
	Links         *Links         `json:"links,omitempty"`
	Relationships *Relationships `json:"relationships,omitempty"`
	Type          string         `json:"type"`
}

// BaseListResponse defines model for BaseListResponse.
type BaseListResponse struct {
	Included []map[string]interface{} `json:"included"`
	Links    Links                    `json:"links"`
	Meta     ListMeta                 `json:"meta"`
}

// BaseObjectResponse defines model for BaseObjectResponse.
type BaseObjectResponse struct {
	Included []map[string]interface{} `json:"included"`
	Meta     ObjectMeta               `json:"meta"`
}

// Links defines model for Links.
type Links struct {
	Arrangements         *string           `json:"arrangements,omitempty"`
	AssignTags           *string           `json:"assign_tags,omitempty"`
	Attachments          *string           `json:"attachments,omitempty"`
	LastScheduledItem    *string           `json:"last_scheduled_item,omitempty"`
	Self                 string            `json:"self"`
	SongSchedules        *string           `json:"song_schedules,omitempty"`
	Tags                 *string           `json:"tags,omitempty"`
	AdditionalProperties map[string]string `json:"-"`
}

// ListMeta defines model for ListMeta.
type ListMeta struct {
	CanInclude *[]string `json:"can_include,omitempty"`
	CanOrderBy *[]string `json:"can_order_by,omitempty"`
	CanQueryBy *[]string `json:"can_query_by,omitempty"`
	Count      int       `json:"count"`
	Next       *struct {
		Offset *int `json:"offset,omitempty"`
	} `json:"next,omitempty"`
	Parent     MetaParent `json:"parent"`
	TotalCount int        `json:"total_count"`
}

// MetaParent defines model for MetaParent.
type MetaParent struct {
	Id   *string `json:"id,omitempty"`
	Type *string `json:"type,omitempty"`
}

// ObjectMeta defines model for ObjectMeta.
type ObjectMeta struct {
	Parent MetaParent `json:"parent"`
}

// RelationshipObject defines model for RelationshipObject.
type RelationshipObject struct {
	Data struct {
		Id   *string `json:"id,omitempty"`
		Type *string `json:"type,omitempty"`
	} `json:"data"`
}

// Relationships defines model for Relationships.
type Relationships struct {
	CreatedBy            *RelationshipObject           `json:"created_by,omitempty"`
	Song                 *RelationshipObject           `json:"song,omitempty"`
	UpdatedBy            *RelationshipObject           `json:"updated_by,omitempty"`
	AdditionalProperties map[string]RelationshipObject `json:"-"`
}

// Song defines model for Song.
type Song struct {
	Attributes struct {
		Admin                   *string    `json:"admin,omitempty"`
		Author                  *string    `json:"author,omitempty"`
		CcliNumber              *int       `json:"ccli_number,omitempty"`
		Copyright               *string    `json:"copyright,omitempty"`
		CreatedAt               *time.Time `json:"created_at,omitempty"`
		Hidden                  *bool      `json:"hidden,omitempty"`
		LastScheduledAt         *time.Time `json:"last_scheduled_at,omitempty"`
		LastScheduledShortDates *string    `json:"last_scheduled_short_dates,omitempty"`
		Notes                   *string    `json:"notes,omitempty"`
		Themes                  *string    `json:"themes,omitempty"`
		Title                   string     `json:"title"`
		UpdatedAt               *time.Time `json:"updated_at,omitempty"`
	} `json:"attributes"`
	Id            string         `json:"id"`
	Links         *Links         `json:"links,omitempty"`
	Relationships *Relationships `json:"relationships,omitempty"`
	Type          string         `json:"type"`
}

// SongListResponse defines model for SongListResponse.
type SongListResponse struct {
	Data     []Song                   `json:"data"`
	Included []map[string]interface{} `json:"included"`
	Links    Links                    `json:"links"`
	Meta     ListMeta                 `json:"meta"`
}

// SongQuery defines model for SongQuery.
type SongQuery struct {
	ArrangementName           *string `json:"arrangement_name,omitempty"`
	ArrangementRehearsalMixId *string `json:"arrangement_rehearsal_mix_id,omitempty"`
	ArrangementTagGroupIds    *string `json:"arrangement_tag_group_ids,omitempty"`
	ArrangementTagIds         *string `json:"arrangement_tag_ids,omitempty"`
	Author                    *string `json:"author,omitempty"`
	BpmMax                    *string `json:"bpm_max,omitempty"`
	BpmMin                    *string `json:"bpm_min,omitempty"`
	CcliNumber                *string `json:"ccli_number,omitempty"`
	EndingKey                 *string `json:"ending_key,omitempty"`
	EndingKeyMinor            *string `json:"ending_key_minor,omitempty"`
	FolderId                  *string `json:"folder_id,omitempty"`
	Hidden                    *string `json:"hidden,omitempty"`
	KeyName                   *string `json:"key_name,omitempty"`
	Lyrics                    *string `json:"lyrics,omitempty"`
	Meter                     *string `json:"meter,omitempty"`
	ServiceTypeId             *string `json:"service_type_id,omitempty"`
	SongTagGroupIds           *string `json:"song_tag_group_ids,omitempty"`
	SongTagIds                *string `json:"song_tag_ids,omitempty"`
	StartingKey               *string `json:"starting_key,omitempty"`
	StartingKeyMinor          *string `json:"starting_key_minor,omitempty"`
	Themes                    *string `json:"themes,omitempty"`
	Title                     *string `json:"title,omitempty"`
}

// SongResponse defines model for SongResponse.
type SongResponse struct {
	Data     Song                     `json:"data"`
	Included []map[string]interface{} `json:"included"`
	Meta     ObjectMeta               `json:"meta"`
}

// ArrangementIdParam defines model for arrangementIdParam.
type ArrangementIdParam = string

// ListOrderParam defines model for listOrderParam.
type ListOrderParam string

// OffsetParam defines model for offsetParam.
type OffsetParam = int

// PerPageParam defines model for perPageParam.
type PerPageParam = int

// SongIdParam defines model for songIdParam.
type SongIdParam = string

// GetSongs200Response defines model for GetSongs200Response.
type GetSongs200Response = SongListResponse

// GetSongsParams defines parameters for GetSongs.
type GetSongsParams struct {
	// Where query parameters
	Where   *SongQuery           `json:"where,omitempty"`
	Order   *GetSongsParamsOrder `form:"order,omitempty" json:"order,omitempty"`
	Offset  *OffsetParam         `form:"offset,omitempty" json:"offset,omitempty"`
	PerPage *PerPageParam        `form:"per_page,omitempty" json:"per_page,omitempty"`
}

// GetSongsParamsOrder defines parameters for GetSongs.
type GetSongsParamsOrder string

// GetArrangementsParams defines parameters for GetArrangements.
type GetArrangementsParams struct {
	Include *[]GetArrangementsParamsInclude `form:"include,omitempty" json:"include,omitempty"`
	Offset  *OffsetParam                    `form:"offset,omitempty" json:"offset,omitempty"`
	PerPage *PerPageParam                   `form:"per_page,omitempty" json:"per_page,omitempty"`
}

// GetArrangementsParamsInclude defines parameters for GetArrangements.
type GetArrangementsParamsInclude string

// GetArrangementSectionsParams defines parameters for GetArrangementSections.
type GetArrangementSectionsParams struct {
	Offset  *OffsetParam  `form:"offset,omitempty" json:"offset,omitempty"`
	PerPage *PerPageParam `form:"per_page,omitempty" json:"per_page,omitempty"`
}

// Getter for additional properties for Links. Returns the specified
// element and whether it was found
func (a Links) Get(fieldName string) (value string, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for Links
func (a *Links) Set(fieldName string, value string) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]string)
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for Links to handle AdditionalProperties
func (a *Links) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["arrangements"]; found {
		err = json.Unmarshal(raw, &a.Arrangements)
		if err != nil {
			return fmt.Errorf("error reading 'arrangements': %w", err)
		}
		delete(object, "arrangements")
	}

	if raw, found := object["assign_tags"]; found {
		err = json.Unmarshal(raw, &a.AssignTags)
		if err != nil {
			return fmt.Errorf("error reading 'assign_tags': %w", err)
		}
		delete(object, "assign_tags")
	}

	if raw, found := object["attachments"]; found {
		err = json.Unmarshal(raw, &a.Attachments)
		if err != nil {
			return fmt.Errorf("error reading 'attachments': %w", err)
		}
		delete(object, "attachments")
	}

	if raw, found := object["last_scheduled_item"]; found {
		err = json.Unmarshal(raw, &a.LastScheduledItem)
		if err != nil {
			return fmt.Errorf("error reading 'last_scheduled_item': %w", err)
		}
		delete(object, "last_scheduled_item")
	}

	if raw, found := object["self"]; found {
		err = json.Unmarshal(raw, &a.Self)
		if err != nil {
			return fmt.Errorf("error reading 'self': %w", err)
		}
		delete(object, "self")
	}

	if raw, found := object["song_schedules"]; found {
		err = json.Unmarshal(raw, &a.SongSchedules)
		if err != nil {
			return fmt.Errorf("error reading 'song_schedules': %w", err)
		}
		delete(object, "song_schedules")
	}

	if raw, found := object["tags"]; found {
		err = json.Unmarshal(raw, &a.Tags)
		if err != nil {
			return fmt.Errorf("error reading 'tags': %w", err)
		}
		delete(object, "tags")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]string)
		for fieldName, fieldBuf := range object {
			var fieldVal string
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshalling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for Links to handle AdditionalProperties
func (a Links) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	if a.Arrangements != nil {
		object["arrangements"], err = json.Marshal(a.Arrangements)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'arrangements': %w", err)
		}
	}

	if a.AssignTags != nil {
		object["assign_tags"], err = json.Marshal(a.AssignTags)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'assign_tags': %w", err)
		}
	}

	if a.Attachments != nil {
		object["attachments"], err = json.Marshal(a.Attachments)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'attachments': %w", err)
		}
	}

	if a.LastScheduledItem != nil {
		object["last_scheduled_item"], err = json.Marshal(a.LastScheduledItem)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'last_scheduled_item': %w", err)
		}
	}

	object["self"], err = json.Marshal(a.Self)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'self': %w", err)
	}

	if a.SongSchedules != nil {
		object["song_schedules"], err = json.Marshal(a.SongSchedules)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'song_schedules': %w", err)
		}
	}

	if a.Tags != nil {
		object["tags"], err = json.Marshal(a.Tags)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'tags': %w", err)
		}
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for Relationships. Returns the specified
// element and whether it was found
func (a Relationships) Get(fieldName string) (value RelationshipObject, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for Relationships
func (a *Relationships) Set(fieldName string, value RelationshipObject) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]RelationshipObject)
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for Relationships to handle AdditionalProperties
func (a *Relationships) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["created_by"]; found {
		err = json.Unmarshal(raw, &a.CreatedBy)
		if err != nil {
			return fmt.Errorf("error reading 'created_by': %w", err)
		}
		delete(object, "created_by")
	}

	if raw, found := object["song"]; found {
		err = json.Unmarshal(raw, &a.Song)
		if err != nil {
			return fmt.Errorf("error reading 'song': %w", err)
		}
		delete(object, "song")
	}

	if raw, found := object["updated_by"]; found {
		err = json.Unmarshal(raw, &a.UpdatedBy)
		if err != nil {
			return fmt.Errorf("error reading 'updated_by': %w", err)
		}
		delete(object, "updated_by")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]RelationshipObject)
		for fieldName, fieldBuf := range object {
			var fieldVal RelationshipObject
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshalling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for Relationships to handle AdditionalProperties
func (a Relationships) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	if a.CreatedBy != nil {
		object["created_by"], err = json.Marshal(a.CreatedBy)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'created_by': %w", err)
		}
	}

	if a.Song != nil {
		object["song"], err = json.Marshal(a.Song)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'song': %w", err)
		}
	}

	if a.UpdatedBy != nil {
		object["updated_by"], err = json.Marshal(a.UpdatedBy)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'updated_by': %w", err)
		}
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// RequestEditorFn  is the function signature for the RequestEditor callback function
type RequestEditorFn func(ctx context.Context, req *http.Request) error

// Doer performs HTTP requests.
//
// The standard http.Client implements this interface.
type HttpRequestDoer interface {
	Do(req *http.Request) (*http.Response, error)
}

// Client which conforms to the OpenAPI3 specification for this service.
type Client struct {
	// The endpoint of the server conforming to this interface, with scheme,
	// https://api.deepmap.com for example. This can contain a path relative
	// to the server, such as https://api.deepmap.com/dev-test, and all the
	// paths in the swagger spec will be appended to the server.
	Server string

	// Doer for performing requests, typically a *http.Client with any
	// customized settings, such as certificate chains.
	Client HttpRequestDoer

	// A list of callbacks for modifying requests which are generated before sending over
	// the network.
	RequestEditors []RequestEditorFn
}

// ClientOption allows setting custom parameters during construction
type ClientOption func(*Client) error

// Creates a new Client, with reasonable defaults
func NewClient(server string, opts ...ClientOption) (*Client, error) {
	// create a client with sane default values
	client := Client{
		Server: server,
	}
	// mutate client and add all optional params
	for _, o := range opts {
		if err := o(&client); err != nil {
			return nil, err
		}
	}
	// ensure the server URL always has a trailing slash
	if !strings.HasSuffix(client.Server, "/") {
		client.Server += "/"
	}
	// create httpClient, if not already present
	if client.Client == nil {
		client.Client = &http.Client{}
	}
	return &client, nil
}

// WithHTTPClient allows overriding the default Doer, which is
// automatically created using http.Client. This is useful for tests.
func WithHTTPClient(doer HttpRequestDoer) ClientOption {
	return func(c *Client) error {
		c.Client = doer
		return nil
	}
}

// WithRequestEditorFn allows setting up a callback function, which will be
// called right before sending the request. This can be used to mutate the request.
func WithRequestEditorFn(fn RequestEditorFn) ClientOption {
	return func(c *Client) error {
		c.RequestEditors = append(c.RequestEditors, fn)
		return nil
	}
}

// The interface specification for the client above.
type ClientInterface interface {
	// GetSongs request
	GetSongs(ctx context.Context, params *GetSongsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetSong request
	GetSong(ctx context.Context, songId SongIdParam, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetArrangements request
	GetArrangements(ctx context.Context, songId SongIdParam, params *GetArrangementsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetArrangement request
	GetArrangement(ctx context.Context, songId SongIdParam, arrangementId ArrangementIdParam, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetArrangementSections request
	GetArrangementSections(ctx context.Context, songId SongIdParam, arrangementId ArrangementIdParam, params *GetArrangementSectionsParams, reqEditors ...RequestEditorFn) (*http.Response, error)
}

func (c *Client) GetSongs(ctx context.Context, params *GetSongsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSongsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetSong(ctx context.Context, songId SongIdParam, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSongRequest(c.Server, songId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetArrangements(ctx context.Context, songId SongIdParam, params *GetArrangementsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetArrangementsRequest(c.Server, songId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetArrangement(ctx context.Context, songId SongIdParam, arrangementId ArrangementIdParam, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetArrangementRequest(c.Server, songId, arrangementId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetArrangementSections(ctx context.Context, songId SongIdParam, arrangementId ArrangementIdParam, params *GetArrangementSectionsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetArrangementSectionsRequest(c.Server, songId, arrangementId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

// NewGetSongsRequest generates requests for GetSongs
func NewGetSongsRequest(server string, params *GetSongsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/songs")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Where != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("deepObject", true, "where", runtime.ParamLocationQuery, *params.Where); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Order != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "order", runtime.ParamLocationQuery, *params.Order); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Offset != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.PerPage != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "per_page", runtime.ParamLocationQuery, *params.PerPage); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetSongRequest generates requests for GetSong
func NewGetSongRequest(server string, songId SongIdParam) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "songId", runtime.ParamLocationPath, songId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/songs/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetArrangementsRequest generates requests for GetArrangements
func NewGetArrangementsRequest(server string, songId SongIdParam, params *GetArrangementsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "songId", runtime.ParamLocationPath, songId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/songs/%s/arrangements", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Include != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "include", runtime.ParamLocationQuery, *params.Include); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Offset != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.PerPage != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "per_page", runtime.ParamLocationQuery, *params.PerPage); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetArrangementRequest generates requests for GetArrangement
func NewGetArrangementRequest(server string, songId SongIdParam, arrangementId ArrangementIdParam) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "songId", runtime.ParamLocationPath, songId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "arrangementId", runtime.ParamLocationPath, arrangementId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/songs/%s/arrangements/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetArrangementSectionsRequest generates requests for GetArrangementSections
func NewGetArrangementSectionsRequest(server string, songId SongIdParam, arrangementId ArrangementIdParam, params *GetArrangementSectionsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "songId", runtime.ParamLocationPath, songId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "arrangementId", runtime.ParamLocationPath, arrangementId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/songs/%s/arrangements/%s/sections", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Offset != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.PerPage != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "per_page", runtime.ParamLocationQuery, *params.PerPage); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

func (c *Client) applyEditors(ctx context.Context, req *http.Request, additionalEditors []RequestEditorFn) error {
	for _, r := range c.RequestEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	for _, r := range additionalEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	return nil
}

// ClientWithResponses builds on ClientInterface to offer response payloads
type ClientWithResponses struct {
	ClientInterface
}

// NewClientWithResponses creates a new ClientWithResponses, which wraps
// Client with return type handling
func NewClientWithResponses(server string, opts ...ClientOption) (*ClientWithResponses, error) {
	client, err := NewClient(server, opts...)
	if err != nil {
		return nil, err
	}
	return &ClientWithResponses{client}, nil
}

// WithBaseURL overrides the baseURL.
func WithBaseURL(baseURL string) ClientOption {
	return func(c *Client) error {
		newBaseURL, err := url.Parse(baseURL)
		if err != nil {
			return err
		}
		c.Server = newBaseURL.String()
		return nil
	}
}

// ClientWithResponsesInterface is the interface specification for the client with responses above.
type ClientWithResponsesInterface interface {
	// GetSongs request
	GetSongsWithResponse(ctx context.Context, params *GetSongsParams, reqEditors ...RequestEditorFn) (*GetSongsResponse, error)

	// GetSong request
	GetSongWithResponse(ctx context.Context, songId SongIdParam, reqEditors ...RequestEditorFn) (*GetSongResponse, error)

	// GetArrangements request
	GetArrangementsWithResponse(ctx context.Context, songId SongIdParam, params *GetArrangementsParams, reqEditors ...RequestEditorFn) (*GetArrangementsResponse, error)

	// GetArrangement request
	GetArrangementWithResponse(ctx context.Context, songId SongIdParam, arrangementId ArrangementIdParam, reqEditors ...RequestEditorFn) (*GetArrangementResponse, error)

	// GetArrangementSections request
	GetArrangementSectionsWithResponse(ctx context.Context, songId SongIdParam, arrangementId ArrangementIdParam, params *GetArrangementSectionsParams, reqEditors ...RequestEditorFn) (*GetArrangementSectionsResponse, error)
}

type GetSongsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SongListResponse
}

// Status returns HTTPResponse.Status
func (r GetSongsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSongsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetSongResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SongResponse
}

// Status returns HTTPResponse.Status
func (r GetSongResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSongResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetArrangementsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ArrangementListResponse
}

// Status returns HTTPResponse.Status
func (r GetArrangementsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetArrangementsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetArrangementResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ArrangementResponse
}

// Status returns HTTPResponse.Status
func (r GetArrangementResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetArrangementResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetArrangementSectionsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ArrangementSectionsResponse
}

// Status returns HTTPResponse.Status
func (r GetArrangementSectionsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetArrangementSectionsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// GetSongsWithResponse request returning *GetSongsResponse
func (c *ClientWithResponses) GetSongsWithResponse(ctx context.Context, params *GetSongsParams, reqEditors ...RequestEditorFn) (*GetSongsResponse, error) {
	rsp, err := c.GetSongs(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSongsResponse(rsp)
}

// GetSongWithResponse request returning *GetSongResponse
func (c *ClientWithResponses) GetSongWithResponse(ctx context.Context, songId SongIdParam, reqEditors ...RequestEditorFn) (*GetSongResponse, error) {
	rsp, err := c.GetSong(ctx, songId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSongResponse(rsp)
}

// GetArrangementsWithResponse request returning *GetArrangementsResponse
func (c *ClientWithResponses) GetArrangementsWithResponse(ctx context.Context, songId SongIdParam, params *GetArrangementsParams, reqEditors ...RequestEditorFn) (*GetArrangementsResponse, error) {
	rsp, err := c.GetArrangements(ctx, songId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetArrangementsResponse(rsp)
}

// GetArrangementWithResponse request returning *GetArrangementResponse
func (c *ClientWithResponses) GetArrangementWithResponse(ctx context.Context, songId SongIdParam, arrangementId ArrangementIdParam, reqEditors ...RequestEditorFn) (*GetArrangementResponse, error) {
	rsp, err := c.GetArrangement(ctx, songId, arrangementId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetArrangementResponse(rsp)
}

// GetArrangementSectionsWithResponse request returning *GetArrangementSectionsResponse
func (c *ClientWithResponses) GetArrangementSectionsWithResponse(ctx context.Context, songId SongIdParam, arrangementId ArrangementIdParam, params *GetArrangementSectionsParams, reqEditors ...RequestEditorFn) (*GetArrangementSectionsResponse, error) {
	rsp, err := c.GetArrangementSections(ctx, songId, arrangementId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetArrangementSectionsResponse(rsp)
}

// ParseGetSongsResponse parses an HTTP response from a GetSongsWithResponse call
func ParseGetSongsResponse(rsp *http.Response) (*GetSongsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetSongsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SongListResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetSongResponse parses an HTTP response from a GetSongWithResponse call
func ParseGetSongResponse(rsp *http.Response) (*GetSongResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetSongResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SongResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetArrangementsResponse parses an HTTP response from a GetArrangementsWithResponse call
func ParseGetArrangementsResponse(rsp *http.Response) (*GetArrangementsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetArrangementsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ArrangementListResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetArrangementResponse parses an HTTP response from a GetArrangementWithResponse call
func ParseGetArrangementResponse(rsp *http.Response) (*GetArrangementResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetArrangementResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ArrangementResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetArrangementSectionsResponse parses an HTTP response from a GetArrangementSectionsWithResponse call
func ParseGetArrangementSectionsResponse(rsp *http.Response) (*GetArrangementSectionsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetArrangementSectionsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ArrangementSectionsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}
