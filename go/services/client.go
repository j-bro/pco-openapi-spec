// Package Services provides primitives to interact the openapi HTTP API.
//
// Code generated by github.com/deepmap/oapi-codegen DO NOT EDIT.
package services

import (
	"bytes"
	"compress/gzip"
	"context"
	"encoding/base64"
	"encoding/json"
	"fmt"
	"github.com/deepmap/oapi-codegen/pkg/runtime"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
	"github.com/pkg/errors"
	"io/ioutil"
	"net/http"
	"strings"
	"time"
)

// Arrangement defines model for Arrangement.
type Arrangement struct {
	// Embedded struct due to allOf(#/components/schemas/BaseDataObject)
	BaseDataObject
	// Embedded fields due to inline allOf schema
	Attributes struct {
		ArchivedAt           *time.Time `json:"archived_at,omitempty"`
		Bpm                  *float32   `json:"bpm,omitempty"`
		ChordChart           *string    `json:"chord_chart,omitempty"`
		ChordChartChordColor *int       `json:"chord_chart_chord_color,omitempty"`
		ChordChartColumns    *int       `json:"chord_chart_columns,omitempty"`
		ChordChartFont       *string    `json:"chord_chart_font,omitempty"`
		ChordChartFontSize   *int       `json:"chord_chart_font_size,omitempty"`
		ChordChartKey        *string    `json:"chord_chart_key,omitempty"`
		CreatedAt            *time.Time `json:"created_at,omitempty"`
		HasChordChart        *bool      `json:"has_chord_chart,omitempty"`
		HasChords            *bool      `json:"has_chords,omitempty"`
		Length               *int       `json:"length,omitempty"`
		Lyrics               *string    `json:"lyrics,omitempty"`
		LyricsEnabled        *bool      `json:"lyrics_enabled,omitempty"`
		Meter                *string    `json:"meter,omitempty"`
		Name                 string     `json:"name"`
		Notes                *string    `json:"notes,omitempty"`
		NumberChartEnabled   *bool      `json:"number_chart_enabled,omitempty"`
		NumeralChartEnabled  *bool      `json:"numeral_chart_enabled,omitempty"`
		PrintMargin          *string    `json:"print_margin,omitempty"`
		PrintOrientation     *string    `json:"print_orientation,omitempty"`
		PrintPageSize        *string    `json:"print_page_size,omitempty"`
		Sequence             *[]string  `json:"sequence,omitempty"`
		SequenceFull         *[]struct {
			Id     *int    `json:"id,omitempty"`
			Label  *string `json:"label,omitempty"`
			Number *int    `json:"number,omitempty"`
		} `json:"sequence_full,omitempty"`
		SequenceShort *[]string  `json:"sequence_short,omitempty"`
		UpdatedAt     *time.Time `json:"updated_at,omitempty"`
	} `json:"attributes"`
}

// ArrangementListResponse defines model for ArrangementListResponse.
type ArrangementListResponse struct {
	// Embedded struct due to allOf(#/components/schemas/BaseListResponse)
	BaseListResponse
	// Embedded fields due to inline allOf schema
	Data *[]Arrangement `json:"data,omitempty"`
}

// ArrangementResponse defines model for ArrangementResponse.
type ArrangementResponse struct {
	// Embedded struct due to allOf(#/components/schemas/BaseObjectResponse)
	BaseObjectResponse
	// Embedded fields due to inline allOf schema
	Data *Arrangement `json:"data,omitempty"`
}

// ArrangementSections defines model for ArrangementSections.
type ArrangementSections struct {
	// Embedded struct due to allOf(#/components/schemas/BaseDataObject)
	BaseDataObject
	// Embedded fields due to inline allOf schema
	Attributes struct {
		Sections *[]struct {
			BreaksAt *string `json:"breaks_at,omitempty"`
			Label    *string `json:"label,omitempty"`
			Lyrics   *string `json:"lyrics,omitempty"`
		} `json:"sections,omitempty"`
	} `json:"attributes"`
}

// ArrangementSectionsResponse defines model for ArrangementSectionsResponse.
type ArrangementSectionsResponse struct {
	// Embedded struct due to allOf(#/components/schemas/BaseObjectResponse)
	BaseObjectResponse
	// Embedded fields due to inline allOf schema
	Data *ArrangementSections `json:"data,omitempty"`
}

// BaseDataObject defines model for BaseDataObject.
type BaseDataObject struct {
	Id            string         `json:"id"`
	Links         *Links         `json:"links,omitempty"`
	Relationships *Relationships `json:"relationships,omitempty"`
	Type          string         `json:"type"`
}

// BaseListResponse defines model for BaseListResponse.
type BaseListResponse struct {
	Included []map[string]interface{} `json:"included"`
	Links    Links                    `json:"links"`
	Meta     ListMeta                 `json:"meta"`
}

// BaseObjectResponse defines model for BaseObjectResponse.
type BaseObjectResponse struct {
	Included []map[string]interface{} `json:"included"`
	Meta     ObjectMeta               `json:"meta"`
}

// Links defines model for Links.
type Links struct {
	Arrangements         *string           `json:"arrangements,omitempty"`
	AssignTags           *string           `json:"assign_tags,omitempty"`
	Attachments          *string           `json:"attachments,omitempty"`
	LastScheduledItem    *string           `json:"last_scheduled_item,omitempty"`
	Self                 string            `json:"self"`
	SongSchedules        *string           `json:"song_schedules,omitempty"`
	Tags                 *string           `json:"tags,omitempty"`
	AdditionalProperties map[string]string `json:"-"`
}

// ListMeta defines model for ListMeta.
type ListMeta struct {
	CanInclude *[]string `json:"can_include,omitempty"`
	CanOrderBy *[]string `json:"can_order_by,omitempty"`
	CanQueryBy *[]string `json:"can_query_by,omitempty"`
	Count      int       `json:"count"`
	Next       *struct {
		Offset *int `json:"offset,omitempty"`
	} `json:"next,omitempty"`
	Parent     MetaParent `json:"parent"`
	TotalCount int        `json:"total_count"`
}

// MetaParent defines model for MetaParent.
type MetaParent struct {
	Id   *string `json:"id,omitempty"`
	Type *string `json:"type,omitempty"`
}

// ObjectMeta defines model for ObjectMeta.
type ObjectMeta struct {
	Parent MetaParent `json:"parent"`
}

// RelationshipObject defines model for RelationshipObject.
type RelationshipObject struct {
	Data struct {
		Id   *string `json:"id,omitempty"`
		Type *string `json:"type,omitempty"`
	} `json:"data"`
}

// Relationships defines model for Relationships.
type Relationships struct {
	CreatedBy            *RelationshipObject           `json:"created_by,omitempty"`
	Song                 *RelationshipObject           `json:"song,omitempty"`
	UpdatedBy            *RelationshipObject           `json:"updated_by,omitempty"`
	AdditionalProperties map[string]RelationshipObject `json:"-"`
}

// Song defines model for Song.
type Song struct {
	// Embedded struct due to allOf(#/components/schemas/BaseDataObject)
	BaseDataObject
	// Embedded fields due to inline allOf schema
	Attributes struct {
		Admin                   *string    `json:"admin,omitempty"`
		Author                  *string    `json:"author,omitempty"`
		CcliNumber              *int       `json:"ccli_number,omitempty"`
		Copyright               *string    `json:"copyright,omitempty"`
		CreatedAt               *time.Time `json:"created_at,omitempty"`
		Hidden                  *bool      `json:"hidden,omitempty"`
		LastScheduledAt         *time.Time `json:"last_scheduled_at,omitempty"`
		LastScheduledShortDates *string    `json:"last_scheduled_short_dates,omitempty"`
		Notes                   *string    `json:"notes,omitempty"`
		Themes                  *string    `json:"themes,omitempty"`
		Title                   string     `json:"title"`
		UpdatedAt               *time.Time `json:"updated_at,omitempty"`
	} `json:"attributes"`
}

// SongListResponse defines model for SongListResponse.
type SongListResponse struct {
	// Embedded struct due to allOf(#/components/schemas/BaseListResponse)
	BaseListResponse
	// Embedded fields due to inline allOf schema
	Data *[]Song `json:"data,omitempty"`
}

// SongQuery defines model for SongQuery.
type SongQuery struct {
	ArrangementName           *string `json:"arrangement_name,omitempty"`
	ArrangementRehearsalMixId *string `json:"arrangement_rehearsal_mix_id,omitempty"`
	ArrangementTagGroupIds    *string `json:"arrangement_tag_group_ids,omitempty"`
	ArrangementTagIds         *string `json:"arrangement_tag_ids,omitempty"`
	Author                    *string `json:"author,omitempty"`
	BpmMax                    *string `json:"bpm_max,omitempty"`
	BpmMin                    *string `json:"bpm_min,omitempty"`
	CcliNumber                *string `json:"ccli_number,omitempty"`
	EndingKey                 *string `json:"ending_key,omitempty"`
	EndingKeyMinor            *string `json:"ending_key_minor,omitempty"`
	FolderId                  *string `json:"folder_id,omitempty"`
	Hidden                    *string `json:"hidden,omitempty"`
	KeyName                   *string `json:"key_name,omitempty"`
	Lyrics                    *string `json:"lyrics,omitempty"`
	Meter                     *string `json:"meter,omitempty"`
	ServiceTypeId             *string `json:"service_type_id,omitempty"`
	SongTagGroupIds           *string `json:"song_tag_group_ids,omitempty"`
	SongTagIds                *string `json:"song_tag_ids,omitempty"`
	StartingKey               *string `json:"starting_key,omitempty"`
	StartingKeyMinor          *string `json:"starting_key_minor,omitempty"`
	Themes                    *string `json:"themes,omitempty"`
	Title                     *string `json:"title,omitempty"`
}

// SongResponse defines model for SongResponse.
type SongResponse struct {
	// Embedded struct due to allOf(#/components/schemas/BaseObjectResponse)
	BaseObjectResponse
	// Embedded fields due to inline allOf schema
	Data *Song `json:"data,omitempty"`
}

// ArrangementIdParam defines model for arrangementIdParam.
type ArrangementIdParam int

// ListOrderParam defines model for listOrderParam.
type ListOrderParam string

// OffsetParam defines model for offsetParam.
type OffsetParam int

// PerPageParam defines model for perPageParam.
type PerPageParam int

// SongIdParam defines model for songIdParam.
type SongIdParam int

// Song defines model for Song.
type SongModel Song

// GetSongsParams defines parameters for GetSongs.
type GetSongsParams struct {
	Where   *SongQuery      `json:"where,omitempty"`
	Order   *ListOrderParam `json:"order,omitempty"`
	Offset  *OffsetParam    `json:"offset,omitempty"`
	PerPage *PerPageParam   `json:"per_page,omitempty"`
}

// GetArrangementsParams defines parameters for GetArrangements.
type GetArrangementsParams struct {
	Include *[]string     `json:"include,omitempty"`
	Offset  *OffsetParam  `json:"offset,omitempty"`
	PerPage *PerPageParam `json:"per_page,omitempty"`
}

// GetArrangementSectionsParams defines parameters for GetArrangementSections.
type GetArrangementSectionsParams struct {
	Offset  *OffsetParam  `json:"offset,omitempty"`
	PerPage *PerPageParam `json:"per_page,omitempty"`
}

// Getter for additional properties for Links. Returns the specified
// element and whether it was found
func (a Links) Get(fieldName string) (value string, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for Links
func (a *Links) Set(fieldName string, value string) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]string)
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for Links to handle AdditionalProperties
func (a *Links) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["arrangements"]; found {
		err = json.Unmarshal(raw, &a.Arrangements)
		if err != nil {
			return errors.Wrap(err, "error reading 'arrangements'")
		}
		delete(object, "arrangements")
	}

	if raw, found := object["assign_tags"]; found {
		err = json.Unmarshal(raw, &a.AssignTags)
		if err != nil {
			return errors.Wrap(err, "error reading 'assign_tags'")
		}
		delete(object, "assign_tags")
	}

	if raw, found := object["attachments"]; found {
		err = json.Unmarshal(raw, &a.Attachments)
		if err != nil {
			return errors.Wrap(err, "error reading 'attachments'")
		}
		delete(object, "attachments")
	}

	if raw, found := object["last_scheduled_item"]; found {
		err = json.Unmarshal(raw, &a.LastScheduledItem)
		if err != nil {
			return errors.Wrap(err, "error reading 'last_scheduled_item'")
		}
		delete(object, "last_scheduled_item")
	}

	if raw, found := object["self"]; found {
		err = json.Unmarshal(raw, &a.Self)
		if err != nil {
			return errors.Wrap(err, "error reading 'self'")
		}
		delete(object, "self")
	}

	if raw, found := object["song_schedules"]; found {
		err = json.Unmarshal(raw, &a.SongSchedules)
		if err != nil {
			return errors.Wrap(err, "error reading 'song_schedules'")
		}
		delete(object, "song_schedules")
	}

	if raw, found := object["tags"]; found {
		err = json.Unmarshal(raw, &a.Tags)
		if err != nil {
			return errors.Wrap(err, "error reading 'tags'")
		}
		delete(object, "tags")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]string)
		for fieldName, fieldBuf := range object {
			var fieldVal string
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return errors.Wrap(err, fmt.Sprintf("error unmarshaling field %s", fieldName))
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for Links to handle AdditionalProperties
func (a Links) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	if a.Arrangements != nil {
		object["arrangements"], err = json.Marshal(a.Arrangements)
		if err != nil {
			return nil, errors.Wrap(err, fmt.Sprintf("error marshaling 'arrangements'"))
		}
	}

	if a.AssignTags != nil {
		object["assign_tags"], err = json.Marshal(a.AssignTags)
		if err != nil {
			return nil, errors.Wrap(err, fmt.Sprintf("error marshaling 'assign_tags'"))
		}
	}

	if a.Attachments != nil {
		object["attachments"], err = json.Marshal(a.Attachments)
		if err != nil {
			return nil, errors.Wrap(err, fmt.Sprintf("error marshaling 'attachments'"))
		}
	}

	if a.LastScheduledItem != nil {
		object["last_scheduled_item"], err = json.Marshal(a.LastScheduledItem)
		if err != nil {
			return nil, errors.Wrap(err, fmt.Sprintf("error marshaling 'last_scheduled_item'"))
		}
	}

	object["self"], err = json.Marshal(a.Self)
	if err != nil {
		return nil, errors.Wrap(err, fmt.Sprintf("error marshaling 'self'"))
	}

	if a.SongSchedules != nil {
		object["song_schedules"], err = json.Marshal(a.SongSchedules)
		if err != nil {
			return nil, errors.Wrap(err, fmt.Sprintf("error marshaling 'song_schedules'"))
		}
	}

	if a.Tags != nil {
		object["tags"], err = json.Marshal(a.Tags)
		if err != nil {
			return nil, errors.Wrap(err, fmt.Sprintf("error marshaling 'tags'"))
		}
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, errors.Wrap(err, fmt.Sprintf("error marshaling '%s'", fieldName))
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for Relationships. Returns the specified
// element and whether it was found
func (a Relationships) Get(fieldName string) (value RelationshipObject, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for Relationships
func (a *Relationships) Set(fieldName string, value RelationshipObject) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]RelationshipObject)
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for Relationships to handle AdditionalProperties
func (a *Relationships) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["created_by"]; found {
		err = json.Unmarshal(raw, &a.CreatedBy)
		if err != nil {
			return errors.Wrap(err, "error reading 'created_by'")
		}
		delete(object, "created_by")
	}

	if raw, found := object["song"]; found {
		err = json.Unmarshal(raw, &a.Song)
		if err != nil {
			return errors.Wrap(err, "error reading 'song'")
		}
		delete(object, "song")
	}

	if raw, found := object["updated_by"]; found {
		err = json.Unmarshal(raw, &a.UpdatedBy)
		if err != nil {
			return errors.Wrap(err, "error reading 'updated_by'")
		}
		delete(object, "updated_by")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]RelationshipObject)
		for fieldName, fieldBuf := range object {
			var fieldVal RelationshipObject
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return errors.Wrap(err, fmt.Sprintf("error unmarshaling field %s", fieldName))
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for Relationships to handle AdditionalProperties
func (a Relationships) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	if a.CreatedBy != nil {
		object["created_by"], err = json.Marshal(a.CreatedBy)
		if err != nil {
			return nil, errors.Wrap(err, fmt.Sprintf("error marshaling 'created_by'"))
		}
	}

	if a.Song != nil {
		object["song"], err = json.Marshal(a.Song)
		if err != nil {
			return nil, errors.Wrap(err, fmt.Sprintf("error marshaling 'song'"))
		}
	}

	if a.UpdatedBy != nil {
		object["updated_by"], err = json.Marshal(a.UpdatedBy)
		if err != nil {
			return nil, errors.Wrap(err, fmt.Sprintf("error marshaling 'updated_by'"))
		}
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, errors.Wrap(err, fmt.Sprintf("error marshaling '%s'", fieldName))
		}
	}
	return json.Marshal(object)
}

// Client which conforms to the OpenAPI3 specification for this service.
type Client struct {
	// The endpoint of the server conforming to this interface, with scheme,
	// https://api.deepmap.com for example.
	Server string

	// HTTP client with any customized settings, such as certificate chains.
	Client http.Client

	// A callback for modifying requests which are generated before sending over
	// the network.
	RequestEditor func(req *http.Request, ctx context.Context) error
}

// The interface specification for the client above.
type ClientInterface interface {
	// GetSongs request
	GetSongs(ctx context.Context, params *GetSongsParams) (*http.Response, error)

	// GetSong request
	GetSong(ctx context.Context, songId SongIdParam) (*http.Response, error)

	// GetArrangements request
	GetArrangements(ctx context.Context, songId SongIdParam, params *GetArrangementsParams) (*http.Response, error)

	// GetArrangement request
	GetArrangement(ctx context.Context, songId SongIdParam, arrangementId ArrangementIdParam) (*http.Response, error)

	// GetArrangementSections request
	GetArrangementSections(ctx context.Context, songId SongIdParam, arrangementId ArrangementIdParam, params *GetArrangementSectionsParams) (*http.Response, error)
}

func (c *Client) GetSongs(ctx context.Context, params *GetSongsParams) (*http.Response, error) {
	req, err := NewGetSongsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(req, ctx)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) GetSong(ctx context.Context, songId SongIdParam) (*http.Response, error) {
	req, err := NewGetSongRequest(c.Server, songId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(req, ctx)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) GetArrangements(ctx context.Context, songId SongIdParam, params *GetArrangementsParams) (*http.Response, error) {
	req, err := NewGetArrangementsRequest(c.Server, songId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(req, ctx)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) GetArrangement(ctx context.Context, songId SongIdParam, arrangementId ArrangementIdParam) (*http.Response, error) {
	req, err := NewGetArrangementRequest(c.Server, songId, arrangementId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(req, ctx)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) GetArrangementSections(ctx context.Context, songId SongIdParam, arrangementId ArrangementIdParam, params *GetArrangementSectionsParams) (*http.Response, error) {
	req, err := NewGetArrangementSectionsRequest(c.Server, songId, arrangementId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(req, ctx)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

// NewGetSongsRequest generates requests for GetSongs
func NewGetSongsRequest(server string, params *GetSongsParams) (*http.Request, error) {
	var err error

	queryUrl := fmt.Sprintf("%s/songs", server)

	var queryStrings []string

	var queryParam0 string
	if params.Where != nil {

		queryParam0, err = runtime.StyleParam("deepObject", true, "where", *params.Where)
		if err != nil {
			return nil, err
		}

		queryStrings = append(queryStrings, queryParam0)
	}

	var queryParam1 string
	if params.Order != nil {

		queryParam1, err = runtime.StyleParam("form", true, "order", *params.Order)
		if err != nil {
			return nil, err
		}

		queryStrings = append(queryStrings, queryParam1)
	}

	var queryParam2 string
	if params.Offset != nil {

		queryParam2, err = runtime.StyleParam("form", true, "offset", *params.Offset)
		if err != nil {
			return nil, err
		}

		queryStrings = append(queryStrings, queryParam2)
	}

	var queryParam3 string
	if params.PerPage != nil {

		queryParam3, err = runtime.StyleParam("form", true, "per_page", *params.PerPage)
		if err != nil {
			return nil, err
		}

		queryStrings = append(queryStrings, queryParam3)
	}

	if len(queryStrings) != 0 {
		queryUrl += "?" + strings.Join(queryStrings, "&")
	}

	req, err := http.NewRequest("GET", queryUrl, nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetSongRequest generates requests for GetSong
func NewGetSongRequest(server string, songId SongIdParam) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParam("simple", false, "songId", songId)
	if err != nil {
		return nil, err
	}

	queryUrl := fmt.Sprintf("%s/songs/%s", server, pathParam0)

	req, err := http.NewRequest("GET", queryUrl, nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetArrangementsRequest generates requests for GetArrangements
func NewGetArrangementsRequest(server string, songId SongIdParam, params *GetArrangementsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParam("simple", false, "songId", songId)
	if err != nil {
		return nil, err
	}

	queryUrl := fmt.Sprintf("%s/songs/%s/arrangements", server, pathParam0)

	var queryStrings []string

	var queryParam0 string
	if params.Include != nil {

		queryParam0, err = runtime.StyleParam("form", true, "include", *params.Include)
		if err != nil {
			return nil, err
		}

		queryStrings = append(queryStrings, queryParam0)
	}

	var queryParam1 string
	if params.Offset != nil {

		queryParam1, err = runtime.StyleParam("form", true, "offset", *params.Offset)
		if err != nil {
			return nil, err
		}

		queryStrings = append(queryStrings, queryParam1)
	}

	var queryParam2 string
	if params.PerPage != nil {

		queryParam2, err = runtime.StyleParam("form", true, "per_page", *params.PerPage)
		if err != nil {
			return nil, err
		}

		queryStrings = append(queryStrings, queryParam2)
	}

	if len(queryStrings) != 0 {
		queryUrl += "?" + strings.Join(queryStrings, "&")
	}

	req, err := http.NewRequest("GET", queryUrl, nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetArrangementRequest generates requests for GetArrangement
func NewGetArrangementRequest(server string, songId SongIdParam, arrangementId ArrangementIdParam) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParam("simple", false, "songId", songId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParam("simple", false, "arrangementId", arrangementId)
	if err != nil {
		return nil, err
	}

	queryUrl := fmt.Sprintf("%s/songs/%s/arrangements/%s", server, pathParam0, pathParam1)

	req, err := http.NewRequest("GET", queryUrl, nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetArrangementSectionsRequest generates requests for GetArrangementSections
func NewGetArrangementSectionsRequest(server string, songId SongIdParam, arrangementId ArrangementIdParam, params *GetArrangementSectionsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParam("simple", false, "songId", songId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParam("simple", false, "arrangementId", arrangementId)
	if err != nil {
		return nil, err
	}

	queryUrl := fmt.Sprintf("%s/songs/%s/arrangements/%s/sections", server, pathParam0, pathParam1)

	var queryStrings []string

	var queryParam0 string
	if params.Offset != nil {

		queryParam0, err = runtime.StyleParam("form", true, "offset", *params.Offset)
		if err != nil {
			return nil, err
		}

		queryStrings = append(queryStrings, queryParam0)
	}

	var queryParam1 string
	if params.PerPage != nil {

		queryParam1, err = runtime.StyleParam("form", true, "per_page", *params.PerPage)
		if err != nil {
			return nil, err
		}

		queryStrings = append(queryStrings, queryParam1)
	}

	if len(queryStrings) != 0 {
		queryUrl += "?" + strings.Join(queryStrings, "&")
	}

	req, err := http.NewRequest("GET", queryUrl, nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// ClientWithResponses builds on ClientInterface to offer response payloads
type ClientWithResponses struct {
	ClientInterface
}

// NewClientWithResponses returns a ClientWithResponses with a default Client:
func NewClientWithResponses(server string) *ClientWithResponses {
	return &ClientWithResponses{
		ClientInterface: &Client{
			Client: http.Client{},
			Server: server,
		},
	}
}

type getSongsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SongListResponse
}

// Status returns HTTPResponse.Status
func (r getSongsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r getSongsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type getSongResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SongResponse
}

// Status returns HTTPResponse.Status
func (r getSongResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r getSongResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type getArrangementsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ArrangementListResponse
}

// Status returns HTTPResponse.Status
func (r getArrangementsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r getArrangementsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type getArrangementResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ArrangementResponse
}

// Status returns HTTPResponse.Status
func (r getArrangementResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r getArrangementResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type getArrangementSectionsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ArrangementSectionsResponse
}

// Status returns HTTPResponse.Status
func (r getArrangementSectionsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r getArrangementSectionsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// GetSongsWithResponse request returning *GetSongsResponse
func (c *ClientWithResponses) GetSongsWithResponse(ctx context.Context, params *GetSongsParams) (*getSongsResponse, error) {
	rsp, err := c.GetSongs(ctx, params)
	if err != nil {
		return nil, err
	}
	return ParsegetSongsResponse(rsp)
}

// GetSongWithResponse request returning *GetSongResponse
func (c *ClientWithResponses) GetSongWithResponse(ctx context.Context, songId SongIdParam) (*getSongResponse, error) {
	rsp, err := c.GetSong(ctx, songId)
	if err != nil {
		return nil, err
	}
	return ParsegetSongResponse(rsp)
}

// GetArrangementsWithResponse request returning *GetArrangementsResponse
func (c *ClientWithResponses) GetArrangementsWithResponse(ctx context.Context, songId SongIdParam, params *GetArrangementsParams) (*getArrangementsResponse, error) {
	rsp, err := c.GetArrangements(ctx, songId, params)
	if err != nil {
		return nil, err
	}
	return ParsegetArrangementsResponse(rsp)
}

// GetArrangementWithResponse request returning *GetArrangementResponse
func (c *ClientWithResponses) GetArrangementWithResponse(ctx context.Context, songId SongIdParam, arrangementId ArrangementIdParam) (*getArrangementResponse, error) {
	rsp, err := c.GetArrangement(ctx, songId, arrangementId)
	if err != nil {
		return nil, err
	}
	return ParsegetArrangementResponse(rsp)
}

// GetArrangementSectionsWithResponse request returning *GetArrangementSectionsResponse
func (c *ClientWithResponses) GetArrangementSectionsWithResponse(ctx context.Context, songId SongIdParam, arrangementId ArrangementIdParam, params *GetArrangementSectionsParams) (*getArrangementSectionsResponse, error) {
	rsp, err := c.GetArrangementSections(ctx, songId, arrangementId, params)
	if err != nil {
		return nil, err
	}
	return ParsegetArrangementSectionsResponse(rsp)
}

// ParsegetSongsResponse parses an HTTP response from a GetSongsWithResponse call
func ParsegetSongsResponse(rsp *http.Response) (*getSongsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &getSongsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		response.JSON200 = &SongListResponse{}
		if err := json.Unmarshal(bodyBytes, response.JSON200); err != nil {
			return nil, err
		}
	case rsp.StatusCode == 400:
		break // No content-type
	case rsp.StatusCode == 404:
		break // No content-type
	}

	return response, nil
}

// ParsegetSongResponse parses an HTTP response from a GetSongWithResponse call
func ParsegetSongResponse(rsp *http.Response) (*getSongResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &getSongResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		response.JSON200 = &SongResponse{}
		if err := json.Unmarshal(bodyBytes, response.JSON200); err != nil {
			return nil, err
		}
	case rsp.StatusCode == 400:
		break // No content-type
	case rsp.StatusCode == 404:
		break // No content-type
	}

	return response, nil
}

// ParsegetArrangementsResponse parses an HTTP response from a GetArrangementsWithResponse call
func ParsegetArrangementsResponse(rsp *http.Response) (*getArrangementsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &getArrangementsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		response.JSON200 = &ArrangementListResponse{}
		if err := json.Unmarshal(bodyBytes, response.JSON200); err != nil {
			return nil, err
		}
	}

	return response, nil
}

// ParsegetArrangementResponse parses an HTTP response from a GetArrangementWithResponse call
func ParsegetArrangementResponse(rsp *http.Response) (*getArrangementResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &getArrangementResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		response.JSON200 = &ArrangementResponse{}
		if err := json.Unmarshal(bodyBytes, response.JSON200); err != nil {
			return nil, err
		}
	}

	return response, nil
}

// ParsegetArrangementSectionsResponse parses an HTTP response from a GetArrangementSectionsWithResponse call
func ParsegetArrangementSectionsResponse(rsp *http.Response) (*getArrangementSectionsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &getArrangementSectionsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		response.JSON200 = &ArrangementSectionsResponse{}
		if err := json.Unmarshal(bodyBytes, response.JSON200); err != nil {
			return nil, err
		}
	}

	return response, nil
}

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Get songs// (GET /songs)
	GetSongs(ctx echo.Context, params GetSongsParams) error
	// Get song by ID// (GET /songs/{songId})
	GetSong(ctx echo.Context, songId SongIdParam) error
	// (GET /songs/{songId}/arrangements)
	GetArrangements(ctx echo.Context, songId SongIdParam, params GetArrangementsParams) error
	// (GET /songs/{songId}/arrangements/{arrangementId})
	GetArrangement(ctx echo.Context, songId SongIdParam, arrangementId ArrangementIdParam) error
	// (GET /songs/{songId}/arrangements/{arrangementId}/sections)
	GetArrangementSections(ctx echo.Context, songId SongIdParam, arrangementId ArrangementIdParam, params GetArrangementSectionsParams) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// GetSongs converts echo context to params.
func (w *ServerInterfaceWrapper) GetSongs(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params GetSongsParams
	// ------------- Optional query parameter "where" -------------
	if paramValue := ctx.QueryParam("where"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("deepObject", true, false, "where", ctx.QueryParams(), &params.Where)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter where: %s", err))
	}

	// ------------- Optional query parameter "order" -------------
	if paramValue := ctx.QueryParam("order"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "order", ctx.QueryParams(), &params.Order)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter order: %s", err))
	}

	// ------------- Optional query parameter "offset" -------------
	if paramValue := ctx.QueryParam("offset"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "offset", ctx.QueryParams(), &params.Offset)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter offset: %s", err))
	}

	// ------------- Optional query parameter "per_page" -------------
	if paramValue := ctx.QueryParam("per_page"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "per_page", ctx.QueryParams(), &params.PerPage)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter per_page: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetSongs(ctx, params)
	return err
}

// GetSong converts echo context to params.
func (w *ServerInterfaceWrapper) GetSong(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "songId" -------------
	var songId SongIdParam

	err = runtime.BindStyledParameter("simple", false, "songId", ctx.Param("songId"), &songId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter songId: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetSong(ctx, songId)
	return err
}

// GetArrangements converts echo context to params.
func (w *ServerInterfaceWrapper) GetArrangements(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "songId" -------------
	var songId SongIdParam

	err = runtime.BindStyledParameter("simple", false, "songId", ctx.Param("songId"), &songId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter songId: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params GetArrangementsParams
	// ------------- Optional query parameter "include" -------------
	if paramValue := ctx.QueryParam("include"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "include", ctx.QueryParams(), &params.Include)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include: %s", err))
	}

	// ------------- Optional query parameter "offset" -------------
	if paramValue := ctx.QueryParam("offset"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "offset", ctx.QueryParams(), &params.Offset)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter offset: %s", err))
	}

	// ------------- Optional query parameter "per_page" -------------
	if paramValue := ctx.QueryParam("per_page"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "per_page", ctx.QueryParams(), &params.PerPage)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter per_page: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetArrangements(ctx, songId, params)
	return err
}

// GetArrangement converts echo context to params.
func (w *ServerInterfaceWrapper) GetArrangement(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "songId" -------------
	var songId SongIdParam

	err = runtime.BindStyledParameter("simple", false, "songId", ctx.Param("songId"), &songId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter songId: %s", err))
	}

	// ------------- Path parameter "arrangementId" -------------
	var arrangementId ArrangementIdParam

	err = runtime.BindStyledParameter("simple", false, "arrangementId", ctx.Param("arrangementId"), &arrangementId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter arrangementId: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetArrangement(ctx, songId, arrangementId)
	return err
}

// GetArrangementSections converts echo context to params.
func (w *ServerInterfaceWrapper) GetArrangementSections(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "songId" -------------
	var songId SongIdParam

	err = runtime.BindStyledParameter("simple", false, "songId", ctx.Param("songId"), &songId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter songId: %s", err))
	}

	// ------------- Path parameter "arrangementId" -------------
	var arrangementId ArrangementIdParam

	err = runtime.BindStyledParameter("simple", false, "arrangementId", ctx.Param("arrangementId"), &arrangementId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter arrangementId: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params GetArrangementSectionsParams
	// ------------- Optional query parameter "offset" -------------
	if paramValue := ctx.QueryParam("offset"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "offset", ctx.QueryParams(), &params.Offset)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter offset: %s", err))
	}

	// ------------- Optional query parameter "per_page" -------------
	if paramValue := ctx.QueryParam("per_page"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "per_page", ctx.QueryParams(), &params.PerPage)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter per_page: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetArrangementSections(ctx, songId, arrangementId, params)
	return err
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router runtime.EchoRouter, si ServerInterface) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET("/songs", wrapper.GetSongs)
	router.GET("/songs/:songId", wrapper.GetSong)
	router.GET("/songs/:songId/arrangements", wrapper.GetArrangements)
	router.GET("/songs/:songId/arrangements/:arrangementId", wrapper.GetArrangement)
	router.GET("/songs/:songId/arrangements/:arrangementId/sections", wrapper.GetArrangementSections)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
	"uioAAA==",
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file.
func GetSwagger() (*openapi3.Swagger, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	swagger, err := openapi3.NewSwaggerLoader().LoadSwaggerFromData(buf.Bytes())
	if err != nil {
		return nil, fmt.Errorf("error loading Swagger: %s", err)
	}
	return swagger, nil
}

